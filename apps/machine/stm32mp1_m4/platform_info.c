/*
 * Copyright (c) 2014, Mentor Graphics Corporation
 * All rights reserved.
 * Copyright (c) 2015 Xilinx, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name of Mentor Graphics Corporation nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**************************************************************************
 * FILE NAME
 *
 *       platform_info.c
 *
 * DESCRIPTION
 *
 *       This file implements APIs to get platform specific
 *       information for OpenAMP.
 *
 **************************************************************************/

#include "openamp/hil.h"
#include "metal/atomic.h"
#include "platform_info.h"
#include "stm32mp1xx_hal.h"

/* IPC Device parameters */
#define SHM_ADDR                          (metal_phys_addr_t) 0x10040000 // MCU SRAM3
#define SHM_SIZE                          0x20000   //(128k)

#define VRING0_IPI_VECT                   IPCC_TX0_IRQn 		 // VRING0 (master to remote)
#define VRING1_IPI_VECT                   IPCC_TX1_IRQn          // VRING1 (remote to master)

#define MASTER_CPU_ID                     0
#define REMOTE_CPU_ID                     1
#define IPCC_CPU_A7			  MASTER_CPU_ID
#define IPCC_CPU_M4			  REMOTE_CPU_ID

#define RX_WAIT_KICK		-1
#define RX_NO_MESSAGE		0
#define RX_MESSAGE_RECEIVED	1


/* -- FIX ME: ipi info is to be defined -- */
struct ipi_info {
	const char *name;
	const char *bus_name;
	struct meta_device *dev;
	struct metal_io_region *io;
	metal_phys_addr_t paddr;
	uint32_t ipi_chn_mask;
	int registered;
	atomic_int sync;
};

extern struct hil_platform_ops stm32mp1_proc_ops;

struct hil_proc *proc = NULL;
IPCC_HandleTypeDef hipcc;
uint32_t msg_received= RX_WAIT_KICK;

const struct firmware_info fw_table[] =
{
	{"unknown",
	 0,
	 0}
};

const int fw_table_size = sizeof(fw_table)/sizeof(struct firmware_info);

struct hil_proc *platform_create_proc(int proc_index)
{
	(void) proc_index;
	proc = hil_create_proc(&stm32mp1_proc_ops, REMOTE_CPU_ID, NULL);
	if (!proc)
		return NULL;

	/* Setup IPI info */
	hil_set_vdev_ipi(proc, 0,
		VRING0_IPI_VECT, NULL);
	hil_set_vring_ipi(proc, 0,
		VRING0_IPI_VECT, NULL);
	hil_set_vring_ipi(proc, 1,
		VRING1_IPI_VECT, NULL);

	hil_set_shm (proc, 0, 0, SHM_ADDR, SHM_SIZE);
//	hil_set_rpmsg_channel(proc, 0, RPMSG_CHAN_NAME);
	return proc;
}


/* 
 * Call Back from IPCC Interrupt Handler:
 * this IRQ is generated by A7 master at start to signify that Buffer are 
 * allocated, so that M4 can start transmition
 * then this IRQ is generated to inform that sent message has been treated by 
 * A7
 */
void m4_rx_b0_Acked( IPCC_HandleTypeDef * hipcc,
		     uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
	printf("\r\n[%d] %s: \r\n", __LINE__, __func__);

	if(msg_received == RX_WAIT_KICK)
		msg_received = RX_MESSAGE_RECEIVED;
	else 
		printf("%s: IT spurious\n", __func__);
}


/* Call Back from IPCC Interrupt Handler: message received from A7*/
void m4_rx_b1_Acked( IPCC_HandleTypeDef * hipcc,
		     uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{

	printf("\r\n[%d] %s:\r\n", __LINE__, __func__);

	msg_received = RX_MESSAGE_RECEIVED;
}

/* ACK On Channel 0 following TX from M4 To A7  */
void m4_tx_b0_Acked( IPCC_HandleTypeDef * hipcc,
		     uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{

	printf("\r\n[%d] %s:\r\n", __LINE__, __func__);
	return ;
}

/* ACK On Channel 1 following TX from M4 To A7  */
void m4_tx_b1_Acked( IPCC_HandleTypeDef * hipcc,
		     uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{

	printf("\r\n[%d] %s:\r\n", __LINE__, __func__);
	return ;
}

int ipcc_init(void)
{

	uint32_t ChannelId;

	__HAL_RCC_MBOX_CLK_ENABLE();

	hipcc.Instance = IPCC;

	if (HAL_IPCC_Init(&hipcc) != HAL_OK ) {
		printf("%s: IPCC init fail\n", __func__);
		return -1;
	}

	/* enable m4 receive irq (rx1) */
	HAL_NVIC_SetPriority(IPCC_RX1_IRQn,0,1);
	HAL_NVIC_EnableIRQ(IPCC_RX1_IRQn);

	ChannelId = 0;
	if (HAL_IPCC_ConfigChannel(&hipcc , ChannelId, IPCC_CHANNEL_DIR_RX,
				   m4_rx_b0_Acked )!= HAL_OK ) {
		printf("%s: HAL_IPCC_ConfigChannel RX fail\n", __func__);
		return -1;
	}

	ChannelId = 1;

	if (HAL_IPCC_ConfigChannel(&hipcc , ChannelId, IPCC_CHANNEL_DIR_RX,
				   m4_rx_b1_Acked )!= HAL_OK ) {
		printf("%s: HAL_IPCC_ConfigChannel RX fail\n", __func__);
		return -1;
	}

	/* enable m4 tx ack irq (tx1) */
	HAL_NVIC_SetPriority(IPCC_TX1_IRQn,0,1);
	HAL_NVIC_EnableIRQ(IPCC_TX1_IRQn);
	/* Configure Channels related from A7
	* Channel 0 is used by M4 to Transmit data to A7
	* Channel 1 is used by M4 to received data from A7
	* */
	ChannelId = 0;

	if (HAL_IPCC_ConfigChannel(&hipcc , ChannelId, IPCC_CHANNEL_DIR_TX,
				   m4_tx_b0_Acked )!= HAL_OK ) {
		printf("%s: HAL_IPCC_ConfigChannel TX fail\n", __func__);
		return -1;
	}

 	ChannelId = 1;
 	if (HAL_IPCC_ConfigChannel(&hipcc , ChannelId, IPCC_CHANNEL_DIR_TX,
				   m4_tx_b1_Acked )!= HAL_OK ) {
 		printf("%s: HAL_IPCC_ConfigChannel TX fail\n", __func__);
 		return -1;
 	}
 	
 	return 0;
}

int _poll(struct hil_proc *hil_proc, int nonblock)
{
	if(msg_received == RX_MESSAGE_RECEIVED) {
		hil_notified(proc, (uint32_t)(-1));

		msg_received = RX_MESSAGE_RECEIVED;
		/* baremetal: message is treated, Send Ack to Master CPU */
		printf("sent RX mailbox 1 ack\n\r");
		HAL_IPCC_InformRemoteCpu(&hipcc, 1, IPCC_CHANNEL_DIR_RX);
		msg_received = RX_NO_MESSAGE;

		return 0;
	} else {
		return -EAGAIN;
	}
}


void _notify(struct hil_proc *hil_proc, struct proc_intr *intr_info)
{
	printf("Ch Idx: %d, Ch Dir: %d, CPU Dest %d\n\r",0  , IPCC_CHANNEL_DIR_TX, 
	(uint8_t)hil_proc->cpu_id );

	/* Notify Other CPU about message */
	HAL_IPCC_InformRemoteCpu(&hipcc, 0, IPCC_CHANNEL_DIR_TX);
}

